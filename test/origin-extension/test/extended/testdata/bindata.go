// Code generated by go-bindata.
// sources:
// test/extended/testdata/olm/v1/basic-bd-plain-image.yaml
// test/extended/testdata/olm/v1/basic-bd-registry-image.yaml
// test/extended/testdata/olm/v1/binding-prefligth.yaml
// test/extended/testdata/olm/v1/binding-prefligth_multirole.yaml
// test/extended/testdata/olm/v1/cip.yaml
// test/extended/testdata/olm/v1/clustercatalog-secret-withlabel.yaml
// test/extended/testdata/olm/v1/clustercatalog-secret.yaml
// test/extended/testdata/olm/v1/clustercatalog-withlabel.yaml
// test/extended/testdata/olm/v1/clustercatalog.yaml
// test/extended/testdata/olm/v1/clusterextension-withoutChannel-OwnSingle.yaml
// test/extended/testdata/olm/v1/clusterextension-withselectorExpressions-WithoutChannelVersion.yaml
// test/extended/testdata/olm/v1/clusterextension-withselectorLableExpressions-WithoutChannelVersion.yaml
// test/extended/testdata/olm/v1/clusterextension-withselectorlabel-OwnSingle.yaml
// test/extended/testdata/olm/v1/clusterextension-withselectorlabel-WithoutChannelVersion.yaml
// test/extended/testdata/olm/v1/clusterextension-withselectorlabel.yaml
// test/extended/testdata/olm/v1/clusterextension.yaml
// test/extended/testdata/olm/v1/clusterextensionWithoutChannel.yaml
// test/extended/testdata/olm/v1/clusterextensionWithoutChannelVersion.yaml
// test/extended/testdata/olm/v1/clusterextensionWithoutVersion.yaml
// test/extended/testdata/olm/v1/crd-nginxolm74923.yaml
// test/extended/testdata/olm/v1/icsp-single-mirror.yaml
// test/extended/testdata/olm/v1/itdms-full-mirror.yaml
// test/extended/testdata/olm/v1/prefligth-clusterrole.yaml
// test/extended/testdata/olm/v1/sa-admin.yaml
// test/extended/testdata/olm/v1/sa-nginx-insufficient-bundle.yaml
// test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-clusterrole.yaml
// test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-rbac.yaml
// test/extended/testdata/olm/v1/sa-nginx-limited.yaml
// test/extended/testdata/olm/v1/sa.yaml
// DO NOT EDIT!

package testdata

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _testExtendedTestdataOlmV1BasicBdPlainImageYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: basic-bd-image-template
objects:
- apiVersion: core.rukpak.io/v1alpha2
  kind: BundleDeployment
  metadata:
    name: "${NAME}"
  spec:
    installNamespace: "${NAMESPACE}"
    provisionerClassName: "core-rukpak-io-plain"
    source:
      image:
        ref: "${ADDRESS}"
      type: image
parameters:
- name: NAME
- name: ADDRESS
- name: NAMESPACE
`)

func testExtendedTestdataOlmV1BasicBdPlainImageYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1BasicBdPlainImageYaml, nil
}

func testExtendedTestdataOlmV1BasicBdPlainImageYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1BasicBdPlainImageYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/basic-bd-plain-image.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1BasicBdRegistryImageYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: basic-bd-image-template
objects:
- apiVersion: core.rukpak.io/v1alpha2
  kind: BundleDeployment
  metadata:
    name: "${NAME}"
  spec:
    installNamespace: "${NAMESPACE}"
    provisionerClassName: "core-rukpak-io-registry"
    source:
      image:
        ref: "${ADDRESS}"
      type: image
parameters:
- name: NAME
- name: ADDRESS
- name: NAMESPACE
`)

func testExtendedTestdataOlmV1BasicBdRegistryImageYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1BasicBdRegistryImageYaml, nil
}

func testExtendedTestdataOlmV1BasicBdRegistryImageYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1BasicBdRegistryImageYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/basic-bd-registry-image.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1BindingPrefligthYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-binding-preflight-template
objects:
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${CLUSTERROLESANAME}-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${CLUSTERROLESANAME}"
    subjects:
      - kind: ServiceAccount
        name: "${SANAME}"
        namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${ROLENAME}-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${ROLENAME}"
      namespace: "${NAMESPACE}"
    subjects:
      - kind: ServiceAccount
        name: "${SANAME}"
        namespace: "${NAMESPACE}"
parameters:
  - name: SANAME
  - name: ROLENAME
  - name: CLUSTERROLESANAME
  - name: NAMESPACE
`)

func testExtendedTestdataOlmV1BindingPrefligthYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1BindingPrefligthYaml, nil
}

func testExtendedTestdataOlmV1BindingPrefligthYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1BindingPrefligthYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/binding-prefligth.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1BindingPrefligth_multiroleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-binding-preflight-template
objects:
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${CLUSTERROLESANAME}-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${CLUSTERROLESANAME}"
    subjects:
      - kind: ServiceAccount
        name: "${SANAME}"
        namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${ROLENAME}-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${ROLENAME}"
      namespace: "${NAMESPACE}"
    subjects:
      - kind: ServiceAccount
        name: "${SANAME}"
        namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${WATCHROLENAME}-binding"
      namespace: "${WATCHNAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${WATCHROLENAME}"
      namespace: "${WATCHNAMESPACE}"
    subjects:
      - kind: ServiceAccount
        name: "${SANAME}"
        namespace: "${NAMESPACE}"
parameters:
  - name: SANAME
  - name: ROLENAME
  - name: CLUSTERROLESANAME
  - name: NAMESPACE
  - name: WATCHROLENAME
  - name: WATCHNAMESPACE
`)

func testExtendedTestdataOlmV1BindingPrefligth_multiroleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1BindingPrefligth_multiroleYaml, nil
}

func testExtendedTestdataOlmV1BindingPrefligth_multiroleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1BindingPrefligth_multiroleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/binding-prefligth_multirole.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1CipYaml = []byte(`kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: cip-template
objects:
- apiVersion: config.openshift.io/v1alpha1
  kind: ClusterImagePolicy
  metadata:
    name: "${NAME}"
  spec:
    policy:
      rootOfTrust:
        policyType: PublicKey
        publicKey: # it is public key, so it is not sensitive information
          keyData: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFcFFMeTN6VC92WG0yQlZpaFNicmtCWWxXWXJjMwovT1RYYlFkMTIzRFNJdGNBSWFRQlB3dGhqSkNEK01sNzJaTFhIdWZGUnlmek9kRjM3Q3k5OERHV3hRPT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==
      signedIdentity:
        matchPolicy: "${POLICY}"
    scopes:
    - "${REPO1}"
    - "${REPO2}"
    - "${REPO3}"
    - "${REPO4}"
parameters:
- name: NAME
- name: REPO1
- name: REPO2
- name: REPO3
- name: REPO4
- name: POLICY
  value: "MatchRepoDigestOrExact"
`)

func testExtendedTestdataOlmV1CipYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1CipYaml, nil
}

func testExtendedTestdataOlmV1CipYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1CipYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/cip.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: catalog-secret-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterCatalog
  metadata:
    name: "${NAME}"
    labels:
      "${LABELKEY}: ${LABELVALUE}"
  spec:
    source:
      type: "${TYPE}"
      image:
        pullSecret: "${SECRET}"
        ref: "${IMAGE}"
        pollIntervalMinutes: ${{POLLINTERVALMINUTES}}
parameters:
- name: NAME
- name: TYPE
  value: "Image"
- name: IMAGE
- name: SECRET
- name: POLLINTERVALMINUTES
  value: "60"
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
`)

func testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYaml, nil
}

func testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clustercatalog-secret-withlabel.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClustercatalogSecretYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: catalog-secret-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterCatalog
  metadata:
    name: "${NAME}"
  spec:
    source:
      type: "${TYPE}"
      image:
        pullSecret: "${SECRET}"
        ref: "${IMAGE}"
        pollIntervalMinutes: ${{POLLINTERVALMINUTES}}
parameters:
- name: NAME
- name: TYPE
  value: "Image"
- name: IMAGE
- name: SECRET
- name: POLLINTERVALMINUTES
  value: "60"
`)

func testExtendedTestdataOlmV1ClustercatalogSecretYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClustercatalogSecretYaml, nil
}

func testExtendedTestdataOlmV1ClustercatalogSecretYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClustercatalogSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clustercatalog-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClustercatalogWithlabelYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: catalog-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterCatalog
  metadata:
    name: "${NAME}"
    labels:
      "${LABELKEY}": "${LABELVALUE}"
  spec:
    source:
      type: "${TYPE}"
      image:
        ref: "${IMAGE}"
parameters:
- name: NAME
- name: TYPE
  value: "Image"
- name: IMAGE
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
`)

func testExtendedTestdataOlmV1ClustercatalogWithlabelYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClustercatalogWithlabelYaml, nil
}

func testExtendedTestdataOlmV1ClustercatalogWithlabelYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClustercatalogWithlabelYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clustercatalog-withlabel.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClustercatalogYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: catalog-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterCatalog
  metadata:
    name: "${NAME}"
  spec:
    source:
      type: "${TYPE}"
      image:
        ref: "${IMAGE}"
parameters:
- name: NAME
- name: TYPE
  value: "Image"
- name: IMAGE
`)

func testExtendedTestdataOlmV1ClustercatalogYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClustercatalogYaml, nil
}

func testExtendedTestdataOlmV1ClustercatalogYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClustercatalogYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clustercatalog.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
    annotations:
      olm.operatorframework.io/watch-namespace: "${WATCHNS}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        version: "${VERSION}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: WATCHNS
- name: PACKAGE
- name: VERSION
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withoutChannel-OwnSingle.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        selector:
          matchExpressions:
          - key: "${EXPRESSIONSKEY}"
            operator: "${EXPRESSIONSOPERATOR}"
            values: 
            - "${EXPRESSIONSVALUE1}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: EXPRESSIONSVALUE1
- name: EXPRESSIONSOPERATOR
  # suggest to use case id
- name: EXPRESSIONSKEY
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withselectorExpressions-WithoutChannelVersion.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        selector:
          matchLabels:
            "${LABELKEY}": "${LABELVALUE}"
          matchExpressions:
          - key: "${EXPRESSIONSKEY}"
            operator: "${EXPRESSIONSOPERATOR}"
            values: 
            - "${EXPRESSIONSVALUE1}"
            - "${EXPRESSIONSVALUE2}"
            - "${EXPRESSIONSVALUE3}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
- name: EXPRESSIONSKEY
- name: EXPRESSIONSOPERATOR
- name: EXPRESSIONSVALUE1
- name: EXPRESSIONSVALUE2
- name: EXPRESSIONSVALUE3
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withselectorLableExpressions-WithoutChannelVersion.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
    annotations:
      olm.operatorframework.io/watch-namespace: "${WATCHNS}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        channels:
          - "${CHANNEL}"
        version: "${VERSION}"
        selector:
          matchLabels:
            "${LABELKEY}": "${LABELVALUE}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: WATCHNS
- name: PACKAGE
- name: CHANNEL
- name: VERSION
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withselectorlabel-OwnSingle.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        selector:
          matchLabels:
            "${LABELKEY}": "${LABELVALUE}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withselectorlabel-WithoutChannelVersion.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        channels:
          - "${CHANNEL}"
        version: "${VERSION}"
        selector:
          matchLabels:
            "${LABELKEY}": "${LABELVALUE}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: CHANNEL
- name: VERSION
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: LABELVALUE
  # suggest to use case id
- name: LABELKEY
  value: "olmv1-test"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension-withselectorlabel.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        channels:
          - "${CHANNEL}"
        version: "${VERSION}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: CHANNEL
- name: VERSION
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextension.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionwithoutchannelYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-without-channel-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        version: "${VERSION}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: VERSION
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: SOURCETYPE
  value: "Catalog"


`)

func testExtendedTestdataOlmV1ClusterextensionwithoutchannelYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionwithoutchannelYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionwithoutchannelYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionwithoutchannelYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextensionWithoutChannel.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-without-channel-version-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: SANAME
- name: SOURCETYPE
  value: "Catalog"



`)

func testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextensionWithoutChannelVersion.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ClusterextensionwithoutversionYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: operator-without-channel-template
objects:
- apiVersion: olm.operatorframework.io/v1
  kind: ClusterExtension
  metadata:
    name: "${NAME}"
  spec:
    namespace: "${INSTALLNAMESPACE}"
    serviceAccount:
      name: "${SANAME}"
    source:
      sourceType: "${SOURCETYPE}"
      catalog:
        packageName: "${PACKAGE}"
        channels:
          - "${CHANNEL}"
        upgradeConstraintPolicy: "${POLICY}"
parameters:
- name: NAME
- name: INSTALLNAMESPACE
- name: PACKAGE
- name: CHANNEL
- name: SANAME
- name: POLICY
  value: "CatalogProvided"
- name: SOURCETYPE
  value: "Catalog"

`)

func testExtendedTestdataOlmV1ClusterextensionwithoutversionYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ClusterextensionwithoutversionYaml, nil
}

func testExtendedTestdataOlmV1ClusterextensionwithoutversionYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ClusterextensionwithoutversionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/clusterextensionWithoutVersion.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1CrdNginxolm74923Yaml = []byte(`apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  creationTimestamp: null
  name: nginxolm74923s.cache.example.com
spec:
  group: cache.example.com
  names:
    kind: Nginxolm74923
    listKind: Nginxolm74923List
    plural: nginxolm74923s
    singular: nginxolm74923
  scope: Namespaced
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: Nginxolm74923 is the Schema for the nginxolm74923s API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
              of an object. Servers should convert recognized schemas to the latest
              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
              object represents. Servers may infer this from the endpoint the client
              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: Spec defines the desired state of Nginxolm74923
            type: object
            x-kubernetes-preserve-unknown-fields: true
          status:
            description: Status defines the observed state of Nginxolm74923
            type: object
            x-kubernetes-preserve-unknown-fields: true
        type: object
    served: true
    storage: true
    subresources:
      status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: null
  storedVersions: null
`)

func testExtendedTestdataOlmV1CrdNginxolm74923YamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1CrdNginxolm74923Yaml, nil
}

func testExtendedTestdataOlmV1CrdNginxolm74923Yaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1CrdNginxolm74923YamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/crd-nginxolm74923.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1IcspSingleMirrorYaml = []byte(`kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: icsp-single-mirror-template
objects:
- apiVersion: operator.openshift.io/v1alpha1
  kind: ImageContentSourcePolicy
  metadata:
    name: "${NAME}"
  spec:
    repositoryDigestMirrors:
    - mirrors:
      - "${MIRROR}"
      source: "${SOURCE}"
parameters:
- name: NAME
- name: MIRROR
- name: SOURCE
`)

func testExtendedTestdataOlmV1IcspSingleMirrorYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1IcspSingleMirrorYaml, nil
}

func testExtendedTestdataOlmV1IcspSingleMirrorYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1IcspSingleMirrorYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/icsp-single-mirror.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1ItdmsFullMirrorYaml = []byte(`kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: itdms-full-mirror-template
objects:
- apiVersion: config.openshift.io/v1
  kind: ImageTagMirrorSet
  metadata:
    name: "${NAME}"
  spec:
    imageTagMirrors:
    - mirrors:
      - "${MIRRORNAMESPACE}"
      source: "${SOURCENAMESPACE}"
    - mirrors:
      - "${MIRRORSITE}"
      source: "${SOURCESITE}"
- apiVersion: config.openshift.io/v1
  kind: ImageDigestMirrorSet
  metadata:
    name: "${NAME}"
  spec:
    imageDigestMirrors:
    - mirrors:
      - "${MIRRORNAMESPACE}"
      source: "${SOURCENAMESPACE}"
    - mirrors:
      - "${MIRRORSITE}"
      source: "${SOURCESITE}"
parameters:
- name: NAME
- name: MIRRORSITE
- name: SOURCESITE
- name: MIRRORNAMESPACE
- name: SOURCENAMESPACE


`)

func testExtendedTestdataOlmV1ItdmsFullMirrorYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1ItdmsFullMirrorYaml, nil
}

func testExtendedTestdataOlmV1ItdmsFullMirrorYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1ItdmsFullMirrorYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/itdms-full-mirror.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1PrefligthClusterroleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-preflight-clusterrole-template
objects:
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}"
    rules:
parameters:
  - name: NAME
`)

func testExtendedTestdataOlmV1PrefligthClusterroleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1PrefligthClusterroleYaml, nil
}

func testExtendedTestdataOlmV1PrefligthClusterroleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1PrefligthClusterroleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/prefligth-clusterrole.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaAdminYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-admin-template
objects:
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-admin-clusterrole"
    rules:
      - apiGroups:
        - "*"
        resources:
        - "*"
        verbs:
        - "*"
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-admin-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-admin-clusterrole"
    subjects:
      - kind: ServiceAccount
        name: "${NAME}"
        namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE

`)

func testExtendedTestdataOlmV1SaAdminYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaAdminYaml, nil
}

func testExtendedTestdataOlmV1SaAdminYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaAdminYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa-admin.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaNginxInsufficientBundleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-nginx-insufficient-bundle-template
objects:
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-clusterrole"
    rules:
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [get, list, watch, update, patch, delete]
      # resourceNames:
      # - nginx-ok-v3283-754-15pkpuong3owt1jn01uoyj8lm6p8jlxh03kuouq67dmv
      # - nginx-ok-v3283-754-2r5zqsa9t9nk0tln1f8x36ws3ks9r8cgwi70s2dgnl82
      # - nginx-ok-v3283-75493-metrics-reader
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [get, list, watch, update, patch, delete]
      # resourceNames:
      # - nginx-ok-v3283-754-15pkpuong3owt1jn01uoyj8lm6p8jlxh03kuouq67dmv
      # - nginx-ok-v3283-754-2r5zqsa9t9nk0tln1f8x36ws3ks9r8cgwi70s2dgnl82
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: "${NAME}-installer-role"
      namespace: "${NAMESPACE}"
    rules:
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, create, update, patch, delete]
    #   resourceNames: [nginx-ok-v3283-75493-controller-manager]
    # - apiGroups: [""]
    #   resources: [serviceaccounts]
    #   verbs: [create]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, create, update, patch, delete]
      # resourceNames: [nginx-ok-v3283-75493-controller-manager-metrics-service]
    - apiGroups: [""]
      resources: [services]
      verbs: [create]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [get, list, watch, create, update, patch, delete]
      # resourceNames: [nginx-ok-v3283-75493-controller-manager]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [create]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${NAME}-installer-role-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${NAME}-installer-role"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-rbac-clusterrole"
    rules:
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - coordination.k8s.io
      resources:
      - leases
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - create
      - patch
    - apiGroups:
      - ""
      resources:
      - secrets
      - pods
      - pods/exec
      - pods/log
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - apps
      resources:
      - deployments
      - daemonsets
      - replicasets
      - statefulsets
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - cache.example.com
      resources:
      - "${KINDS}"
      - "${KINDS}/status"
      - "${KINDS}/finalizers"
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - authentication.k8s.io
      resources:
      - tokenreviews
      verbs:
      - create
    - apiGroups:
      - authorization.k8s.io
      resources:
      - subjectaccessreviews
      verbs:
      - create
    - nonResourceURLs:
      - /metrics
      verbs:
      - get
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-rbac-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-rbac-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE
  - name: KINDS
`)

func testExtendedTestdataOlmV1SaNginxInsufficientBundleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaNginxInsufficientBundleYaml, nil
}

func testExtendedTestdataOlmV1SaNginxInsufficientBundleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaNginxInsufficientBundleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa-nginx-insufficient-bundle.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-nginx-insufficient-operand-clusterrole-template
objects:
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-clusterrole"
    rules:
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [create, list, watch]
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [get, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, create, update, patch, delete]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: "${NAME}-installer-role"
      namespace: "${NAMESPACE}"
    rules:
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [create]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [create]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [create]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${NAME}-installer-role-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${NAME}-installer-role"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-rbac-clusterrole"
    rules:
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - coordination.k8s.io
      resources:
      - leases
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - create
      - patch
    - apiGroups:
      - apps
      resources:
      - deployments
      - daemonsets
      - replicasets
      - statefulsets
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - cache.example.com
      resources:
      - "${KINDS}"
      - "${KINDS}/status"
      - "${KINDS}/finalizers"
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - authentication.k8s.io
      resources:
      - tokenreviews
      verbs:
      - create
    - apiGroups:
      - authorization.k8s.io
      resources:
      - subjectaccessreviews
      verbs:
      - create
    - nonResourceURLs:
      - /metrics
      verbs:
      - get
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-rbac-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-rbac-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE
  - name: KINDS
`)

func testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYaml, nil
}

func testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-clusterrole.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-nginx-insufficient-operand-rbac-template
objects:
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-clusterrole"
    rules:
    - apiGroups: [olm.operatorframework.io]
      resources: [clusterextensions/finalizers]
      verbs: [update]
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [create, list, watch]
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [get, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, create, update, patch, delete]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: "${NAME}-installer-role"
      namespace: "${NAMESPACE}"
    rules:
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [create]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [create]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [create]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${NAME}-installer-role-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${NAME}-installer-role"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-rbac-clusterrole"
    rules:
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - coordination.k8s.io
      resources:
      - leases
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - create
      - patch
    - apiGroups:
      - apps
      resources:
      - deployments
      - daemonsets
      - replicasets
      - statefulsets
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - cache.example.com
      resources:
      - "${KINDS}"
      - "${KINDS}/status"
      - "${KINDS}/finalizers"
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - authentication.k8s.io
      resources:
      - tokenreviews
      verbs:
      - create
    - apiGroups:
      - authorization.k8s.io
      resources:
      - subjectaccessreviews
      verbs:
      - create
    - nonResourceURLs:
      - /metrics
      verbs:
      - get
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-rbac-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-rbac-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE
  - name: KINDS
`)

func testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYaml, nil
}

func testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-rbac.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaNginxLimitedYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-nginx-limited-template
objects:
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-clusterrole"
    rules:
    - apiGroups: [olm.operatorframework.io]
      resources: [clusterextensions/finalizers]
      verbs: [update]
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [create, list, watch]
    - apiGroups: [apiextensions.k8s.io]
      resources: [customresourcedefinitions]
      verbs: [get, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterroles]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [create]
    - apiGroups: [rbac.authorization.k8s.io]
      resources: [clusterrolebindings]
      verbs: [get, list, watch, update, patch, delete]
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, create, update, patch, delete]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: "${NAME}-installer-role"
      namespace: "${NAMESPACE}"
    rules:
    - apiGroups: [""]
      resources: [serviceaccounts]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [""]
      resources: [services]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [get, list, watch, create, update, patch, delete]
    - apiGroups: [apps]
      resources: [deployments]
      verbs: [create]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: "${NAME}-installer-role-binding"
      namespace: "${NAMESPACE}"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: "${NAME}-installer-role"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: "${NAME}-installer-rbac-clusterrole"
    rules:
    - apiGroups:
      - ""
      resources:
      - namespaces
      verbs:
      - get
      - list
      - watch
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - coordination.k8s.io
      resources:
      - leases
      verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - create
      - patch
    - apiGroups:
      - ""
      resources:
      - secrets
      - pods
      - pods/exec
      - pods/log
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - apps
      resources:
      - deployments
      - daemonsets
      - replicasets
      - statefulsets
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - cache.example.com
      resources:
      - "${KINDS}"
      - "${KINDS}/status"
      - "${KINDS}/finalizers"
      verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
    - apiGroups:
      - authentication.k8s.io
      resources:
      - tokenreviews
      verbs:
      - create
    - apiGroups:
      - authorization.k8s.io
      resources:
      - subjectaccessreviews
      verbs:
      - create
    - nonResourceURLs:
      - /metrics
      verbs:
      - get
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: "${NAME}-installer-rbac-clusterrole-binding"
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: "${NAME}-installer-rbac-clusterrole"
    subjects:
    - kind: ServiceAccount
      name: "${NAME}"
      namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE
  - name: KINDS
`)

func testExtendedTestdataOlmV1SaNginxLimitedYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaNginxLimitedYaml, nil
}

func testExtendedTestdataOlmV1SaNginxLimitedYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaNginxLimitedYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa-nginx-limited.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testExtendedTestdataOlmV1SaYaml = []byte(`apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: olmv1-sa-template
objects:
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: "${NAME}"
      namespace: "${NAMESPACE}"
parameters:
  - name: NAME
  - name: NAMESPACE
`)

func testExtendedTestdataOlmV1SaYamlBytes() ([]byte, error) {
	return _testExtendedTestdataOlmV1SaYaml, nil
}

func testExtendedTestdataOlmV1SaYaml() (*asset, error) {
	bytes, err := testExtendedTestdataOlmV1SaYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test/extended/testdata/olm/v1/sa.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"test/extended/testdata/olm/v1/basic-bd-plain-image.yaml":                                                testExtendedTestdataOlmV1BasicBdPlainImageYaml,
	"test/extended/testdata/olm/v1/basic-bd-registry-image.yaml":                                             testExtendedTestdataOlmV1BasicBdRegistryImageYaml,
	"test/extended/testdata/olm/v1/binding-prefligth.yaml":                                                   testExtendedTestdataOlmV1BindingPrefligthYaml,
	"test/extended/testdata/olm/v1/binding-prefligth_multirole.yaml":                                         testExtendedTestdataOlmV1BindingPrefligth_multiroleYaml,
	"test/extended/testdata/olm/v1/cip.yaml":                                                                 testExtendedTestdataOlmV1CipYaml,
	"test/extended/testdata/olm/v1/clustercatalog-secret-withlabel.yaml":                                     testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYaml,
	"test/extended/testdata/olm/v1/clustercatalog-secret.yaml":                                               testExtendedTestdataOlmV1ClustercatalogSecretYaml,
	"test/extended/testdata/olm/v1/clustercatalog-withlabel.yaml":                                            testExtendedTestdataOlmV1ClustercatalogWithlabelYaml,
	"test/extended/testdata/olm/v1/clustercatalog.yaml":                                                      testExtendedTestdataOlmV1ClustercatalogYaml,
	"test/extended/testdata/olm/v1/clusterextension-withoutChannel-OwnSingle.yaml":                           testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYaml,
	"test/extended/testdata/olm/v1/clusterextension-withselectorExpressions-WithoutChannelVersion.yaml":      testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYaml,
	"test/extended/testdata/olm/v1/clusterextension-withselectorLableExpressions-WithoutChannelVersion.yaml": testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYaml,
	"test/extended/testdata/olm/v1/clusterextension-withselectorlabel-OwnSingle.yaml":                        testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYaml,
	"test/extended/testdata/olm/v1/clusterextension-withselectorlabel-WithoutChannelVersion.yaml":            testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYaml,
	"test/extended/testdata/olm/v1/clusterextension-withselectorlabel.yaml":                                  testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYaml,
	"test/extended/testdata/olm/v1/clusterextension.yaml":                                                    testExtendedTestdataOlmV1ClusterextensionYaml,
	"test/extended/testdata/olm/v1/clusterextensionWithoutChannel.yaml":                                      testExtendedTestdataOlmV1ClusterextensionwithoutchannelYaml,
	"test/extended/testdata/olm/v1/clusterextensionWithoutChannelVersion.yaml":                               testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYaml,
	"test/extended/testdata/olm/v1/clusterextensionWithoutVersion.yaml":                                      testExtendedTestdataOlmV1ClusterextensionwithoutversionYaml,
	"test/extended/testdata/olm/v1/crd-nginxolm74923.yaml":                                                   testExtendedTestdataOlmV1CrdNginxolm74923Yaml,
	"test/extended/testdata/olm/v1/icsp-single-mirror.yaml":                                                  testExtendedTestdataOlmV1IcspSingleMirrorYaml,
	"test/extended/testdata/olm/v1/itdms-full-mirror.yaml":                                                   testExtendedTestdataOlmV1ItdmsFullMirrorYaml,
	"test/extended/testdata/olm/v1/prefligth-clusterrole.yaml":                                               testExtendedTestdataOlmV1PrefligthClusterroleYaml,
	"test/extended/testdata/olm/v1/sa-admin.yaml":                                                            testExtendedTestdataOlmV1SaAdminYaml,
	"test/extended/testdata/olm/v1/sa-nginx-insufficient-bundle.yaml":                                        testExtendedTestdataOlmV1SaNginxInsufficientBundleYaml,
	"test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-clusterrole.yaml":                           testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYaml,
	"test/extended/testdata/olm/v1/sa-nginx-insufficient-operand-rbac.yaml":                                  testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYaml,
	"test/extended/testdata/olm/v1/sa-nginx-limited.yaml":                                                    testExtendedTestdataOlmV1SaNginxLimitedYaml,
	"test/extended/testdata/olm/v1/sa.yaml":                                                                  testExtendedTestdataOlmV1SaYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//
//	data/
//	  foo.txt
//	  img/
//	    a.png
//	    b.png
//
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"test": {nil, map[string]*bintree{
		"extended": {nil, map[string]*bintree{
			"testdata": {nil, map[string]*bintree{
				"olm": {nil, map[string]*bintree{
					"v1": {nil, map[string]*bintree{
						"basic-bd-plain-image.yaml":                      {testExtendedTestdataOlmV1BasicBdPlainImageYaml, map[string]*bintree{}},
						"basic-bd-registry-image.yaml":                   {testExtendedTestdataOlmV1BasicBdRegistryImageYaml, map[string]*bintree{}},
						"binding-prefligth.yaml":                         {testExtendedTestdataOlmV1BindingPrefligthYaml, map[string]*bintree{}},
						"binding-prefligth_multirole.yaml":               {testExtendedTestdataOlmV1BindingPrefligth_multiroleYaml, map[string]*bintree{}},
						"cip.yaml":                                       {testExtendedTestdataOlmV1CipYaml, map[string]*bintree{}},
						"clustercatalog-secret-withlabel.yaml":           {testExtendedTestdataOlmV1ClustercatalogSecretWithlabelYaml, map[string]*bintree{}},
						"clustercatalog-secret.yaml":                     {testExtendedTestdataOlmV1ClustercatalogSecretYaml, map[string]*bintree{}},
						"clustercatalog-withlabel.yaml":                  {testExtendedTestdataOlmV1ClustercatalogWithlabelYaml, map[string]*bintree{}},
						"clustercatalog.yaml":                            {testExtendedTestdataOlmV1ClustercatalogYaml, map[string]*bintree{}},
						"clusterextension-withoutChannel-OwnSingle.yaml": {testExtendedTestdataOlmV1ClusterextensionWithoutchannelOwnsingleYaml, map[string]*bintree{}},
						"clusterextension-withselectorExpressions-WithoutChannelVersion.yaml":      {testExtendedTestdataOlmV1ClusterextensionWithselectorexpressionsWithoutchannelversionYaml, map[string]*bintree{}},
						"clusterextension-withselectorLableExpressions-WithoutChannelVersion.yaml": {testExtendedTestdataOlmV1ClusterextensionWithselectorlableexpressionsWithoutchannelversionYaml, map[string]*bintree{}},
						"clusterextension-withselectorlabel-OwnSingle.yaml":                        {testExtendedTestdataOlmV1ClusterextensionWithselectorlabelOwnsingleYaml, map[string]*bintree{}},
						"clusterextension-withselectorlabel-WithoutChannelVersion.yaml":            {testExtendedTestdataOlmV1ClusterextensionWithselectorlabelWithoutchannelversionYaml, map[string]*bintree{}},
						"clusterextension-withselectorlabel.yaml":                                  {testExtendedTestdataOlmV1ClusterextensionWithselectorlabelYaml, map[string]*bintree{}},
						"clusterextension.yaml":                          {testExtendedTestdataOlmV1ClusterextensionYaml, map[string]*bintree{}},
						"clusterextensionWithoutChannel.yaml":            {testExtendedTestdataOlmV1ClusterextensionwithoutchannelYaml, map[string]*bintree{}},
						"clusterextensionWithoutChannelVersion.yaml":     {testExtendedTestdataOlmV1ClusterextensionwithoutchannelversionYaml, map[string]*bintree{}},
						"clusterextensionWithoutVersion.yaml":            {testExtendedTestdataOlmV1ClusterextensionwithoutversionYaml, map[string]*bintree{}},
						"crd-nginxolm74923.yaml":                         {testExtendedTestdataOlmV1CrdNginxolm74923Yaml, map[string]*bintree{}},
						"icsp-single-mirror.yaml":                        {testExtendedTestdataOlmV1IcspSingleMirrorYaml, map[string]*bintree{}},
						"itdms-full-mirror.yaml":                         {testExtendedTestdataOlmV1ItdmsFullMirrorYaml, map[string]*bintree{}},
						"prefligth-clusterrole.yaml":                     {testExtendedTestdataOlmV1PrefligthClusterroleYaml, map[string]*bintree{}},
						"sa-admin.yaml":                                  {testExtendedTestdataOlmV1SaAdminYaml, map[string]*bintree{}},
						"sa-nginx-insufficient-bundle.yaml":              {testExtendedTestdataOlmV1SaNginxInsufficientBundleYaml, map[string]*bintree{}},
						"sa-nginx-insufficient-operand-clusterrole.yaml": {testExtendedTestdataOlmV1SaNginxInsufficientOperandClusterroleYaml, map[string]*bintree{}},
						"sa-nginx-insufficient-operand-rbac.yaml":        {testExtendedTestdataOlmV1SaNginxInsufficientOperandRbacYaml, map[string]*bintree{}},
						"sa-nginx-limited.yaml":                          {testExtendedTestdataOlmV1SaNginxLimitedYaml, map[string]*bintree{}},
						"sa.yaml":                                        {testExtendedTestdataOlmV1SaYaml, map[string]*bintree{}},
					}},
				}},
			}},
		}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
